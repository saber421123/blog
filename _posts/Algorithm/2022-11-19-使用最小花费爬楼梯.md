---
layout: post

title: leetcode.746使用最小花费爬楼梯

category: Algorithm

tags: 动态规划

description: leetcode.746使用最小花费爬楼梯

keywords: 动态规划

score: 5.0

coverage: libra_coverage.png

published: true




---

##  [leetcode.746使用最小花费爬楼梯(easy)](https://leetcode.cn/problems/min-cost-climbing-stairs/)

描述：

- ![image-20221120102729180](/assets/imgs/image-20221120102729180.png)

思路：动态规划

题目中说 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯” 也就是相当于 跳到 下标 0 或者 下标 1 是不花费体力的， 从 下标 0 下标1 开始跳就要花费体力了。

1. 确定dp数组以及下标的含义

   使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。

   **dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]**。

   **对于dp数组的定义，大家一定要清晰！**

2. 确定递推公式

   **可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]**。

   dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

   dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

   那么究竟是选从dp[i - 1]跳还是从dp[i - 2]跳呢？

   一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

3. dp数组如何初始化

   看一下递归公式，dp[i]由dp[i - 1]，dp[i - 2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。

   那么 dp[0] 应该是多少呢？ 根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。

   这里就要说名了，本题力扣为什么改题意了，而且修改题意之后 就清晰很多的原因了。

   新题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 从 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。

   所以初始化 dp[0] = 0，dp[1] = 0;


4. 确定遍历顺序

   最后一步，递归公式有了，初始化有了，如何遍历呢？

   本题的遍历顺序其实比较简单，简单到很多同学都忽略了思考这一步直接就把代码写出来了。

   因为是模拟台阶，而且dp[i]由dp[i-1]dp[i-2]推出，所以是从前到后遍历cost数组就可以了。

   > **但是稍稍有点难度的动态规划，其遍历顺序并不容易确定下来**。 例如：01背包，都知道两个for循环，一个for遍历物品嵌套一个for遍历背包容量，那么为什么不是一个for遍历背包容量嵌套一个for遍历物品呢？ 以及在使用一维dp数组的时候遍历背包容量为什么要倒序呢？

   **这些都是遍历顺序息息相关。**

   举例推导dp数组

   拿示例2：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] ，来模拟一下dp数组的状态变化，如下

   ![image-removebg-preview (16)](/assets/imgs/image-removebg-preview (16)-16689114898791.png)



```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        //确定dp数组，dp[i]表示到第i层楼最小体力
        int[] dp = new int[cost.length+1];
        // 因为可以选择从0，或者1开始爬楼梯
        dp[0]=0;
        dp[1]=0;
        for(int i=2;i<=cost.length;i++){
            // 状态转移方程
            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
        }
        
        int res = dp[cost.length];
        return res;
    }
}
```

